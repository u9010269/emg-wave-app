
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>é£›æ©Ÿ EMG éŠæˆ²</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #222;
      color: white;
    }
    #canvas {
      display: block;
      background-color: #88c0d0;
    }
    #ui {
      padding: 10px;
      background-color: #111;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    button {
      padding: 8px 14px;
      font-size: 0.9em;
      background-color: #ffcc00;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #message {
      font-size: 1em;
      margin-left: 20px;
    }
    #emgDisplay {
      font-size: 1em;
      padding: 6px 12px;
      background-color: #333;
      border-radius: 6px;
    }
    #backLink {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: #444;
      color: white;
      padding: 8px 12px;
      text-decoration: none;
      border-radius: 5px;
      z-index: 10;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <a id="backLink" href="emg_with_game_link.html">è¿”å› EMG é é¢</a>
  <div id="ui">
    <button onclick="connectBluetooth()">é€£æ¥è—ç‰™</button>
    <button onclick="startClimbSetup()">ğŸŸ¦ é–‹å§‹è¨­ç½®å½æ›²</button>
    <button onclick="endClimbSetup()">âœ… çµæŸå½æ›²è¨­ç½®</button>
    <button onclick="startShootSetup()">ğŸŸ¥ é–‹å§‹è¨­ç½®æŠ“æ¡</button>
    <button onclick="endShootSetup()">âœ… çµæŸæŠ“æ¡è¨­ç½®</button>
    <button onclick="startGame()">ğŸ® é–‹å§‹éŠæˆ²</button>
    <span id="emgDisplay">EMGï¼š--</span>
    <span id="message">å°šæœªé–‹å§‹</span>
  </div>
  <canvas id="canvas" width="800" height="480"></canvas>
  <canvas id="emgChart" width="800" height="150"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ROWS = 20;
    const rowHeight = canvas.height / ROWS;
    let planeY = 10;
    let emg = 0;
    let emgDisplay = document.getElementById("emgDisplay");
    let message = document.getElementById("message");
    let climbList = [], shootList = [];
    let climbAvg = null, shootAvg = null;
    let climbSetting = false, shootSetting = false;
    let gameStarted = false;
    let characteristic = null;
    let bullets = [];
    let backgroundOffset = 0;
    let lastShootTime = 0;
    const shootCooldown = 400;

    const terrain = Array.from({length: 100}, (_, i) => 300 + Math.sin(i * 0.2) * 40);

    // EMG æ³¢å½¢åœ–åˆå§‹åŒ–
    const chartData = {
      labels: Array(100).fill(''),
      datasets: [{
        label: 'EMG',
        data: Array(100).fill(0),
        borderColor: 'lime',
        borderWidth: 1,
        pointRadius: 0,
        fill: false,
      }]
    };
    const chartConfig = {
      type: 'line',
      data: chartData,
      options: {
        responsive: false,
        animation: false,
        scales: {
          y: { min: 0, max: 1023 }
        }
      }
    };
    const emgChart = new Chart(document.getElementById("emgChart"), chartConfig);

    function updateEMGChart(val) {
      chartData.datasets[0].data.push(val);
      chartData.datasets[0].data.shift();
      emgChart.update('none');
    }

    function connectBluetooth() {
      navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'MLT' }],
        optionalServices: ['ffe0']
      }).then(device => device.gatt.connect())
        .then(server => server.getPrimaryService('ffe0'))
        .then(service => service.getCharacteristic('ffe1'))
        .then(c => {
          characteristic = c;
          readEMGLoop();
          message.innerText = "è—ç‰™å·²é€£æ¥";
        })
        .catch(e => message.innerText = "è—ç‰™é€£æ¥å¤±æ•—ï¼š" + e);
    }

    function startClimbSetup() {
      climbList = [];
      climbSetting = true;
      message.innerText = "é–‹å§‹è¨˜éŒ„å½æ›²æ•¸æ“š...";
    }
    function endClimbSetup() {
      climbSetting = false;
      if (climbList.length > 0) {
        climbAvg = Math.floor(climbList.reduce((a, b) => a + b, 0) / climbList.length);
        message.innerText = "å½æ›²å¹³å‡å€¼è¨­ç‚º " + climbAvg;
      }
    }
    function startShootSetup() {
      shootList = [];
      shootSetting = true;
      message.innerText = "é–‹å§‹è¨˜éŒ„æŠ“æ¡æ•¸æ“š...";
    }
    function endShootSetup() {
      shootSetting = false;
      if (shootList.length > 0) {
        shootAvg = Math.floor(shootList.reduce((a, b) => a + b, 0) / shootList.length);
        message.innerText = "æŠ“æ¡å¹³å‡å€¼è¨­ç‚º " + shootAvg;
      }
    }

    function startGame() {
      if (!climbAvg || !shootAvg) {
        message.innerText = "è«‹å…ˆè¨­å®šå½æ›²èˆ‡æŠ“æ¡å€¼ï¼";
        return;
      }
      message.innerText = "éŠæˆ²å€’æ•¸ 3 ç§’...";
      setTimeout(() => {
        message.innerText = "";
        gameStarted = true;
      }, 3000);
    }

    async function readEMGLoop() {
      while (true) {
        if (!characteristic) return;
        try {
          const value = await characteristic.readValue();
          const text = new TextDecoder().decode(value).trim();
          const val = parseInt(text);
          if (!isNaN(val)) {
            emg = val;
            emgDisplay.innerText = "EMGï¼š" + val;
            updateEMGChart(val);
            if (climbSetting) climbList.push(val);
            if (shootSetting) shootList.push(val);
          }
        } catch {}
        await new Promise(r => setTimeout(r, 30));
      }
    }

    function getClimbDelta() {
      if (!climbAvg) return 0;
      const lower = climbAvg * 0.8;
      const upper = climbAvg * 1.2;
      if (emg < lower) return 0;
      if (emg <= upper) return emg / climbAvg;
      return 1 + ((emg - climbAvg) / climbAvg);
    }

    function shouldShoot() {
      if (!shootAvg) return false;
      const now = Date.now();
      const lower = shootAvg * 0.8;
      const upper = shootAvg * 1.2;
      if (emg >= lower && emg <= upper && (now - lastShootTime > shootCooldown)) {
        lastShootTime = now;
        return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < canvas.width; i++) {
        let tIndex = Math.floor((i + backgroundOffset) / 20) % terrain.length;
        let height = terrain[tIndex];
        ctx.fillStyle = "#654321";
        ctx.fillRect(i, canvas.height - height, 1, height);
        ctx.fillStyle = "#88c070";
        ctx.fillRect(i, canvas.height - height, 1, 5);
      }

      let planePixelY = planeY * rowHeight;
      ctx.fillStyle = "blue";
      ctx.fillRect(80, planePixelY, 40, 20);

      if (gameStarted) {
        planeY -= getClimbDelta() * 0.15;
        planeY += 0.15;
        planeY = Math.max(0, Math.min(ROWS - 1, planeY));

        if (shouldShoot()) {
          bullets.push({ x: 120, y: planePixelY + 8 });
        }

        ctx.fillStyle = "yellow";
        bullets.forEach(b => {
          ctx.fillRect(b.x, b.y, 12, 4);
          b.x += 5;
        });
        bullets = bullets.filter(b => b.x < canvas.width);

        backgroundOffset += 2;
      }

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>

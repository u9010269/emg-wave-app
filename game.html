
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>飛機 EMG 遊戲</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #222;
      color: white;
    }
    #canvas {
      display: block;
      background-color: #88c0d0;
    }
    #ui {
      padding: 10px;
      background-color: #111;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    button {
      padding: 8px 14px;
      font-size: 0.9em;
      background-color: #ffcc00;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #message {
      font-size: 1em;
      margin-left: 20px;
    }
    #emgDisplay {
      font-size: 1em;
      padding: 6px 12px;
      background-color: #333;
      border-radius: 6px;
    }
    #backLink {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: #444;
      color: white;
      padding: 8px 12px;
      text-decoration: none;
      border-radius: 5px;
      z-index: 10;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <a id="backLink" href="emg_with_game_link.html">返回 EMG 頁面</a>
  <div id="ui">
    <button onclick="connectBluetooth()">連接藍牙</button>
    <button onclick="startClimbSetup()">🟦 開始設置彎曲</button>
    <button onclick="endClimbSetup()">✅ 結束彎曲設置</button>
    <button onclick="startShootSetup()">🟥 開始設置抓握</button>
    <button onclick="endShootSetup()">✅ 結束抓握設置</button>
    <button onclick="startGame()">🎮 開始遊戲</button>
    <span id="emgDisplay">EMG：--</span>
    <span id="message">尚未開始</span>
  </div>
  <canvas id="canvas" width="800" height="480"></canvas>
  <canvas id="emgChart" width="800" height="150"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ROWS = 20;
    const rowHeight = canvas.height / ROWS;
    let planeY = 10;
    let emg = 0;
    let emgDisplay = document.getElementById("emgDisplay");
    let message = document.getElementById("message");
    let climbList = [], shootList = [];
    let climbAvg = null, shootAvg = null;
    let climbSetting = false, shootSetting = false;
    let gameStarted = false;
    let characteristic = null;
    let bullets = [];
    let backgroundOffset = 0;
    let lastShootTime = 0;
    const shootCooldown = 400;

    const terrain = Array.from({length: 100}, (_, i) => 300 + Math.sin(i * 0.2) * 40);

    // EMG 波形圖初始化
    const chartData = {
      labels: Array(100).fill(''),
      datasets: [{
        label: 'EMG',
        data: Array(100).fill(0),
        borderColor: 'lime',
        borderWidth: 1,
        pointRadius: 0,
        fill: false,
      }]
    };
    const chartConfig = {
      type: 'line',
      data: chartData,
      options: {
        responsive: false,
        animation: false,
        scales: {
          y: { min: 0, max: 1023 }
        }
      }
    };
    const emgChart = new Chart(document.getElementById("emgChart"), chartConfig);

    function updateEMGChart(val) {
      chartData.datasets[0].data.push(val);
      chartData.datasets[0].data.shift();
      emgChart.update('none');
    }

    function connectBluetooth() {
      navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'MLT' }],
        optionalServices: ['ffe0']
      }).then(device => device.gatt.connect())
        .then(server => server.getPrimaryService('ffe0'))
        .then(service => service.getCharacteristic('ffe1'))
        .then(c => {
          characteristic = c;
          readEMGLoop();
          message.innerText = "藍牙已連接";
        })
        .catch(e => message.innerText = "藍牙連接失敗：" + e);
    }

    function startClimbSetup() {
      climbList = [];
      climbSetting = true;
      message.innerText = "開始記錄彎曲數據...";
    }
    function endClimbSetup() {
      climbSetting = false;
      if (climbList.length > 0) {
        climbAvg = Math.floor(climbList.reduce((a, b) => a + b, 0) / climbList.length);
        message.innerText = "彎曲平均值設為 " + climbAvg;
      }
    }
    function startShootSetup() {
      shootList = [];
      shootSetting = true;
      message.innerText = "開始記錄抓握數據...";
    }
    function endShootSetup() {
      shootSetting = false;
      if (shootList.length > 0) {
        shootAvg = Math.floor(shootList.reduce((a, b) => a + b, 0) / shootList.length);
        message.innerText = "抓握平均值設為 " + shootAvg;
      }
    }

    function startGame() {
      if (!climbAvg || !shootAvg) {
        message.innerText = "請先設定彎曲與抓握值！";
        return;
      }
      message.innerText = "遊戲倒數 3 秒...";
      setTimeout(() => {
        message.innerText = "";
        gameStarted = true;
      }, 3000);
    }

    async function readEMGLoop() {
      while (true) {
        if (!characteristic) return;
        try {
          const value = await characteristic.readValue();
          const text = new TextDecoder().decode(value).trim();
          const val = parseInt(text);
          if (!isNaN(val)) {
            emg = val;
            emgDisplay.innerText = "EMG：" + val;
            updateEMGChart(val);
            if (climbSetting) climbList.push(val);
            if (shootSetting) shootList.push(val);
          }
        } catch {}
        await new Promise(r => setTimeout(r, 30));
      }
    }

    function getClimbDelta() {
      if (!climbAvg) return 0;
      const lower = climbAvg * 0.8;
      const upper = climbAvg * 1.2;
      if (emg < lower) return 0;
      if (emg <= upper) return emg / climbAvg;
      return 1 + ((emg - climbAvg) / climbAvg);
    }

    function shouldShoot() {
      if (!shootAvg) return false;
      const now = Date.now();
      const lower = shootAvg * 0.8;
      const upper = shootAvg * 1.2;
      if (emg >= lower && emg <= upper && (now - lastShootTime > shootCooldown)) {
        lastShootTime = now;
        return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < canvas.width; i++) {
        let tIndex = Math.floor((i + backgroundOffset) / 20) % terrain.length;
        let height = terrain[tIndex];
        ctx.fillStyle = "#654321";
        ctx.fillRect(i, canvas.height - height, 1, height);
        ctx.fillStyle = "#88c070";
        ctx.fillRect(i, canvas.height - height, 1, 5);
      }

      let planePixelY = planeY * rowHeight;
      ctx.fillStyle = "blue";
      ctx.fillRect(80, planePixelY, 40, 20);

      if (gameStarted) {
        planeY -= getClimbDelta() * 0.15;
        planeY += 0.15;
        planeY = Math.max(0, Math.min(ROWS - 1, planeY));

        if (shouldShoot()) {
          bullets.push({ x: 120, y: planePixelY + 8 });
        }

        ctx.fillStyle = "yellow";
        bullets.forEach(b => {
          ctx.fillRect(b.x, b.y, 12, 4);
          b.x += 5;
        });
        bullets = bullets.filter(b => b.x < canvas.width);

        backgroundOffset += 2;
      }

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>


<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>é£›æ©Ÿ EMG éŠæˆ²</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #222;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #ui {
      width: 800px;
      padding: 10px;
      background-color: #111;
      display: flex;
      flex-wrap: wrap;
      justify-content: start;
      gap: 10px;
    }
    button {
      padding: 8px 14px;
      font-size: 0.9em;
      background-color: #ffcc00;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #canvas {
      background-color: #88c0d0;
      display: block;
    }
    #backLink {
      display: inline-block;
      margin: 10px;
      background-color: #444;
      color: white;
      padding: 8px 12px;
      text-decoration: none;
      border-radius: 5px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div id="ui">
    <button onclick="connectBluetooth()">é€£æ¥è—ç‰™</button>
    <button onclick="calibrateBaseline()">ğŸ“ æ ¡æ­£</button>
    <button onclick="startClimbSetup()">ğŸŸ¦ é–‹å§‹è¨­ç½®å½æ›²</button>
    <button onclick="endClimbSetup()">âœ… çµæŸå½æ›²è¨­ç½®</button>
    <button onclick="startShootSetup()">ğŸŸ¥ é–‹å§‹è¨­ç½®æŠ“æ¡</button>
    <button onclick="endShootSetup()">âœ… çµæŸæŠ“æ¡è¨­ç½®</button>
    <button onclick="startGame()">ğŸ® é–‹å§‹éŠæˆ²</button>
    <span id="emgDisplay">EMGï¼š--</span>
    <span id="message">å°šæœªé–‹å§‹</span>
    <span id="baselineDisplay">åŸºæº–å€¼ï¼š--</span>
  </div>

  <canvas id="canvas" width="800" height="480"></canvas>
  <canvas id="emgChart" width="800" height="150"></canvas>
  <a id="backLink" href="index.html">è¿”å› EMG é é¢</a>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ROWS = 20;
    const rowHeight = canvas.height / ROWS;
    let planeY = 10;
    let emg = 0;
    let baselineEMG = 0;
    let isBaselineSet = false;
    let climbList = [], shootList = [];
    let climbAvg = null, shootAvg = null;
    let isClimbSetting = false, isShootSetting = false;
    let gameStarted = false;
    let characteristic = null;
    let bullets = [];
    let backgroundOffset = 0;
    let lastShootTime = 0;
    const shootCooldown = 400;

    const terrain = Array.from({length: 100}, (_, i) => 300 + Math.sin(i * 0.2) * 40);
    const emgDisplay = document.getElementById("emgDisplay");
    const message = document.getElementById("message");

    const chartData = {
      labels: Array(100).fill(''),
      datasets: [{
        label: 'EMG',
        data: Array(100).fill(0),
        borderColor: 'lime',
        borderWidth: 1,
        pointRadius: 0,
        fill: false,
      }]
    };
    const emgChart = new Chart(document.getElementById("emgChart"), {
      type: 'line',
      data: chartData,
      options: {
        responsive: false,
        animation: false,
        scales: { y: { min: 0, max: 1023 } }
      }
    });
    function updateEMGChart(val) {
      chartData.datasets[0].data.push(val);
      chartData.datasets[0].data.shift();
      emgChart.update('none');
    }

    function calibrateBaseline() {
      if (!characteristic) {
        alert("è«‹å…ˆé€£æ¥è—ç‰™");
        return;
      }
      alert("è«‹æ”¾é¬†æ‰‹éƒ¨ï¼Œé–‹å§‹æ ¡æ­£...");
      let sum = 0, count = 0;
      const interval = setInterval(async () => {
        const value = await characteristic.readValue();
        const val = parseInt(new TextDecoder().decode(value).trim());
        if (!isNaN(val)) {
          sum += val;
          count++;
        }
        if (count >= 100) {
          clearInterval(interval);
          baselineEMG = Math.floor(sum / count);
          isBaselineSet = true;
          document.getElementById("baselineDisplay").innerText = "åŸºæº–å€¼ï¼š" + baselineEMG;
          alert("æ ¡æ­£å®Œæˆï¼åŸºæº–å€¼ï¼š" + baselineEMG);
        }
      }, 30);
    }

    function connectBluetooth() {
      navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'MLT' }],
        optionalServices: ['ffe0']
      }).then(device => device.gatt.connect())
        .then(server => server.getPrimaryService('ffe0'))
        .then(service => service.getCharacteristic('ffe1'))
        .then(c => {
          characteristic = c;
          readEMGLoop();
          message.innerText = "è—ç‰™å·²é€£æ¥";
        })
        .catch(e => message.innerText = "è—ç‰™é€£æ¥å¤±æ•—ï¼š" + e);
    }

    function startClimbSetup() { climbList = []; isClimbSetting = true; message.innerText = "é–‹å§‹è¨˜éŒ„å½æ›²..."; }
    function endClimbSetup() {
      isClimbSetting = false;
      if (climbList.length > 0) {
        climbAvg = Math.floor(climbList.reduce((a, b) => a + b, 0) / climbList.length);
        message.innerText = "å½æ›²å¹³å‡ï¼š" + climbAvg;
      }
    }
    function startShootSetup() { shootList = []; isShootSetting = true; message.innerText = "é–‹å§‹è¨˜éŒ„æŠ“æ¡..."; }
    function endShootSetup() {
      isShootSetting = false;
      if (shootList.length > 0) {
        shootAvg = Math.floor(shootList.reduce((a, b) => a + b, 0) / shootList.length);
        message.innerText = "æŠ“æ¡å¹³å‡ï¼š" + shootAvg;
      }
    }

    function startGame() {
      if (!climbAvg || !shootAvg) {
        message.innerText = "è«‹å…ˆå®Œæˆè¨­ç½®";
        return;
      }
      message.innerText = "éŠæˆ²å³å°‡é–‹å§‹...";
      setTimeout(() => {
        gameStarted = true;
        message.innerText = "";
      }, 3000);
    }

    async function readEMGLoop() {
      while (true) {
        if (!characteristic) return;
        try {
          const value = await characteristic.readValue();
          const val = parseInt(new TextDecoder().decode(value).trim());
          if (!isNaN(val)) {
            emg = isBaselineSet ? Math.max(0, (val - baselineEMG) * 4) : val;
            emgDisplay.innerText = "EMGï¼š" + emg;
            updateEMGChart(emg);
            if (isClimbSetting) climbList.push(emg);
            if (isShootSetting) shootList.push(emg);
          }
        } catch {}
        await new Promise(r => setTimeout(r, 30));
      }
    }

    function getClimbDelta() {
      if (!climbAvg) return 0;
      const lower = climbAvg * 0.9;
      const upper = climbAvg * 1.1;
      if (emg < lower) return 0;
      if (emg <= upper) return 0.2;
      return 0.2 + ((emg - upper) / climbAvg);
    }

    function shouldShoot() {
      if (!shootAvg) return false;
      const now = Date.now();
      const lower = shootAvg * 0.8;
      const upper = shootAvg * 1.2;
      if (emg >= lower && emg <= upper && (now - lastShootTime > shootCooldown)) {
        lastShootTime = now;
        return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < canvas.width; i++) {
        let tIndex = Math.floor((i + backgroundOffset) / 20) % terrain.length;
        let height = terrain[tIndex];
        ctx.fillStyle = "#654321";
        ctx.fillRect(i, canvas.height - height, 1, height);
        ctx.fillStyle = "#88c070";
        ctx.fillRect(i, canvas.height - height, 1, 5);
      }

      let planePixelY = planeY * rowHeight;
      ctx.fillStyle = "blue";
      ctx.fillRect(80, planePixelY, 40, 20);

      if (gameStarted) {
        planeY += 0.1;
        planeY -= getClimbDelta();
        planeY = Math.max(0, Math.min(ROWS - 1, planeY));

        if (shouldShoot()) bullets.push({ x: 120, y: planePixelY + 8 });

        ctx.fillStyle = "yellow";
        bullets.forEach(b => {
          ctx.fillRect(b.x, b.y, 12, 4);
          b.x += 5;
        });
        bullets = bullets.filter(b => b.x < canvas.width);

        backgroundOffset += 2;
      }

      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>

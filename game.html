
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>é£›æ©Ÿ EMG éŠæˆ²</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #222;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #ui {
      width: 800px;
      padding: 10px;
      background-color: #111;
      display: flex;
      flex-wrap: wrap;
      justify-content: start;
      gap: 10px;
      z-index: 10;
    }
    button {
      padding: 8px 14px;
      font-size: 0.9em;
      background-color: #ffcc00;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #message {
      font-size: 1em;
      margin-left: auto;
    }
    #emgDisplay {
      font-size: 1em;
      padding: 6px 12px;
      background-color: #333;
      border-radius: 6px;
    }
    #canvas {
      background-color: #88c0d0;
      display: block;
    }
    #backLink {
      display: inline-block;
      margin: 10px;
      background-color: #444;
      color: white;
      padding: 8px 12px;
      text-decoration: none;
      border-radius: 5px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div id="ui">
    <button id="btnConnect">é€£æ¥è—ç‰™</button>
    <button id="btnStartClimb">ğŸŸ¦ é–‹å§‹è¨­ç½®å½æ›²</button>
    <button id="btnEndClimb">âœ… çµæŸå½æ›²è¨­ç½®</button>
    <button id="btnStartShoot">ğŸŸ¥ é–‹å§‹è¨­ç½®æŠ“æ¡</button>
    <button id="btnEndShoot">âœ… çµæŸæŠ“æ¡è¨­ç½®</button>
    <button id="btnStartGame">ğŸ® é–‹å§‹éŠæˆ²</button>
    <span id="emgDisplay">EMGï¼š--</span>
    <span id="message">å°šæœªé–‹å§‹</span>
  </div>

  <canvas id="canvas" width="800" height="480"></canvas>
  <canvas id="emgChart" width="800" height="150"></canvas>
  <a id="backLink" href="emg_with_game_link.html">è¿”å› EMG é é¢</a>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const ROWS = 20;
    const rowHeight = canvas.height / ROWS;
    let planeY = 10;
    let emg = 0;
    let climbList = [], shootList = [];
    let climbAvg = null, shootAvg = null;
    let isClimbSetting = false, isShootSetting = false;
    let gameStarted = false;
    let characteristic = null;
    let bullets = [];
    let backgroundOffset = 0;
    let lastShootTime = 0;
    const shootCooldown = 400;
    const terrain = Array.from({length: 100}, (_, i) => 300 + Math.sin(i * 0.2) * 40);
    const emgDisplay = document.getElementById("emgDisplay");
    const message = document.getElementById("message");

    const chartData = {
      labels: Array(100).fill(''),
      datasets: [{
        label: 'EMG',
        data: Array(100).fill(0),
        borderColor: 'lime',
        borderWidth: 1,
        pointRadius: 0,
        fill: false,
      }]
    };
    const emgChart = new Chart(document.getElementById("emgChart"), {
      type: 'line',
      data: chartData,
      options: {
        responsive: false,
        animation: false,
        scales: { y: { min: 0, max: 1023 } }
      }
    });
    function updateEMGChart(val) {
      chartData.datasets[0].data.push(val);
      chartData.datasets[0].data.shift();
      emgChart.update('none');
    }

    document.getElementById("btnConnect").onclick = async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'MLT' }],
          optionalServices: ['ffe0']
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService('ffe0');
        characteristic = await service.getCharacteristic('ffe1');
        readEMGLoop();
        message.innerText = "è—ç‰™å·²é€£æ¥";
      } catch (e) {
        message.innerText = "è—ç‰™é€£æ¥å¤±æ•—ï¼š" + e;
      }
    };

    document.getElementById("btnStartClimb").onclick = () => {
      climbList = [];
      isClimbSetting = true;
      message.innerText = "é–‹å§‹è¨˜éŒ„å½æ›²æ•¸æ“š...";
    };
    document.getElementById("btnEndClimb").onclick = () => {
      isClimbSetting = false;
      if (climbList.length > 0) {
        climbAvg = Math.floor(climbList.reduce((a, b) => a + b, 0) / climbList.length);
        message.innerText = "å½æ›²å¹³å‡å€¼è¨­ç‚º " + climbAvg;
      }
    };

    document.getElementById("btnStartShoot").onclick = () => {
      shootList = [];
      isShootSetting = true;
      message.innerText = "é–‹å§‹è¨˜éŒ„æŠ“æ¡æ•¸æ“š...";
    };
    document.getElementById("btnEndShoot").onclick = () => {
      isShootSetting = false;
      if (shootList.length > 0) {
        shootAvg = Math.floor(shootList.reduce((a, b) => a + b, 0) / shootList.length);
        message.innerText = "æŠ“æ¡å¹³å‡å€¼è¨­ç‚º " + shootAvg;
      }
    };

    document.getElementById("btnStartGame").onclick = () => {
      if (!climbAvg || !shootAvg) {
        message.innerText = "è«‹å…ˆè¨­å®šå½æ›²èˆ‡æŠ“æ¡å€¼";
        return;
      }
      message.innerText = "éŠæˆ²å€’æ•¸ 3 ç§’...";
      setTimeout(() => {
        message.innerText = "";
        gameStarted = true;
      }, 3000);
    };

    async function readEMGLoop() {
      while (true) {
        if (!characteristic) return;
        try {
          const value = await characteristic.readValue();
          const text = new TextDecoder().decode(value).trim();
          const val = parseInt(text);
          if (!isNaN(val)) {
            emg = val;
            emgDisplay.innerText = "EMGï¼š" + val;
            updateEMGChart(val);
            if (isClimbSetting) climbList.push(val);
            if (isShootSetting) shootList.push(val);
          }
        } catch {}
        await new Promise(r => setTimeout(r, 30));
      }
    }

    
function getClimbDelta() {
  if (!climbAvg) return 0;
  const lower = climbAvg * 0.8;
  const upper = climbAvg * 1.2;
  if (emg < lower) return 0;
  if (emg <= upper) return 1.2; // åœ¨å€é–“å…§ç›´æ¥çµ¦ 1.2 å€¼è£œæ¨åŠ›
  return 1 + ((emg - climbAvg) / climbAvg);
}

    function shouldShoot() {
      if (!shootAvg) return false;
      const now = Date.now();
      const lower = shootAvg * 0.8;
      const upper = shootAvg * 1.2;
      if (emg >= lower && emg <= upper && (now - lastShootTime > shootCooldown)) {
        lastShootTime = now;
        return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < canvas.width; i++) {
        let tIndex = Math.floor((i + backgroundOffset) / 20) % terrain.length;
        let height = terrain[tIndex];
        ctx.fillStyle = "#654321";
        ctx.fillRect(i, canvas.height - height, 1, height);
        ctx.fillStyle = "#88c070";
        ctx.fillRect(i, canvas.height - height, 1, 5);
      }

      let planePixelY = planeY * rowHeight;
      ctx.fillStyle = "blue";
      ctx.fillRect(80, planePixelY, 40, 20);

      if (gameStarted) {
        planeY += 0.1;
        planeY -= getClimbDelta() * 0.2;
        planeY = Math.max(0, Math.min(ROWS - 1, planeY));

        if (shouldShoot()) {
          bullets.push({ x: 120, y: planePixelY + 8 });
        }

        ctx.fillStyle = "yellow";
        bullets.forEach(b => {
          ctx.fillRect(b.x, b.y, 12, 4);
          b.x += 5;
        });
        bullets = bullets.filter(b => b.x < canvas.width);

        backgroundOffset += 2;
      }

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>

<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>EMG å›å¾©ç©©å®šç‰ˆï¼ˆå«éŸ³æ•ˆèˆ‡UIï¼‰</title>
<style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { max-width: 100%; height: 250px; }
    .btn-group { margin-top: 10px; margin-bottom: 10px; }
    button {
      font-size: 1.1em; padding: 8px 16px; margin-right: 10px; margin-bottom: 6px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    select, input[type="number"] {
      font-size: 1em; margin-left: 10px;
    }
  </style>
<script src="https://cdn.jsdelivr.net/npm/chart.js">
</script></head>
<body>
<h2>EMG åŸå§‹æ³¢å½¢åœ–ï¼ˆè±ªå“¥1.19ï¼‰</h2>
<div class="btn-group">
<button id="toggleMp3Btn" onclick="toggleMp3()" style="background-color:#ff6600; color:white;">åˆ‡æ›MP3éŸ³æ•ˆï¼ˆç›®å‰ï¼šé—œï¼‰</button>
<label>MP3é–€æª»å€¼ï¼š<input id="mp3Threshold" style="width: 80px;" type="number" value="350"/></label>
</div>
<div class="btn-group">
<button onclick="connect()" style="background-color:#28a745; color:white;">é€£æ¥è—ç‰™</button>
<button id="pauseBtn" onclick="togglePause()" style="background-color:#007BFF; color:white;">æš«åœ</button>
</div>
<p id="value">åŸå§‹æ•¸å€¼ï¼š--</p>
<canvas id="emgChart"></canvas>
<h2 id="zoomTitle">EMG æ ¡æ­£æ³¢å½¢åœ–ï¼ˆè™•ç†æ¨¡å¼ï¼‰
    <button onclick="performCalibration()" style="background-color:#ffc107; color:black; font-size: 0.9em; margin-left: 10px;">ğŸ“ æ ¡æ­£</button>
</h2>
<canvas id="zoomChart"></canvas>
<p id="adjusted">æ ¡æ­£å¾Œæ•¸å€¼ï¼š--</p>
<p id="mvc">å³æ™‚å¼·åº¦ï¼š-- %</p>
<div class="btn-group">
<label>æ ¡æ­£æ•¸å€¼å€ç‡ï¼š
      <select id="amplifyRate">
<option value="1">100%</option>
<option value="1.2">120%</option>
<option value="1.4">140%</option>
<option value="1.6">160%</option>
<option value="1.8">180%</option>
<option value="2">200%</option>
</select>
</label>
</div>
<div class="btn-group">
<button onclick="setMode('raw')" style="background-color:#17a2b8; color:white;">åŸå§‹</button>
<button onclick="setMode('mean')" style="background-color:#17a2b8; color:white;">å¹³å‡</button>
<button onclick="setMode('max')" style="background-color:#17a2b8; color:white;">æœ€å¤§å€¼</button>
<button onclick="setMode('rms')" style="background-color:#17a2b8; color:white;">RMS</button>
<button onclick="resetMax()" style="background-color:#6c757d; color:white;">é‡è¨­æœ€å¤§å€¼</button>
</div>
<script>
    let characteristic, pauseBtn = null;
    let isPaused = false, soundEnabled = true, isCalibrated = false;
    let calibrationBaseline = 0, maxAdjusted = 1;
    let audioCtx = null, oscillator = null, gainNode = null;
    let mode = 'raw';
    const AVG_WINDOW = 10;
    let emgBuffer = Array(AVG_WINDOW).fill(0);
    const rawData = Array(100).fill(0);
    const zoomData = Array(100).fill(0);

    const emgChart = new Chart(document.getElementById('emgChart'), {
      type: 'line',
      data: { labels: Array(100).fill(''), datasets: [{ label: 'åŸå§‹ EMG', data: rawData, borderColor: 'blue', borderWidth: 1 }] },
      options: { animation: false, responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1023 } } }
    });

    const zoomChart = new Chart(document.getElementById('zoomChart'), {
      type: 'line',
      data: { labels: Array(100).fill(''), datasets: [{ label: 'æ ¡æ­£å¾Œ EMG', data: zoomData, borderColor: 'green', borderWidth: 1 }] },
      options: { animation: false, responsive: true, scales: { y: { min: -100, max: 200 }, x: { grid: { display: true } } } }
    });

    function getProcessedEMG(val) {
      emgBuffer.push(val); emgBuffer.shift();
      if (mode === 'raw') return val;
      if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
      if (mode === 'max') return Math.max(...emgBuffer);
      if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
      return val;
    }

    function setMode(m) {
      mode = m;
      alert('æ¨¡å¼åˆ‡æ›ç‚ºï¼š' + m);
    }

    function resetMax() {
      maxAdjusted = 1;
      zoomChart.update();
    }

    async function connect() {
      const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'MLT' }], optionalServices: ['ffe0'] });
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('ffe0');
      characteristic = await service.getCharacteristic('ffe1');
      pauseBtn = document.getElementById('pauseBtn');
      setInterval(readEMG, 30);
    }

    function togglePause() {
      isPaused = !isPaused;
      pauseBtn.innerText = isPaused ? "æ¢å¾©" : "æš«åœ";
    }

    function startSoundEngine() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);
        oscillator = audioCtx.createOscillator();
        oscillator.connect(gainNode);
        oscillator.start();
        gainNode.gain.value = 0;
      }
    }

    function toggleSound() {
      soundEnabled = !soundEnabled;
      document.querySelector("button[onclick='toggleSound()']").innerText = "åˆ‡æ›éŸ³æ•ˆï¼ˆç›®å‰ï¼š" + (soundEnabled ? "é–‹" : "é—œ") + "ï¼‰";
    }

    async function performCalibration() {
      let sum = 0, count = 0;
      alert("è«‹ä¿æŒæ”¾é¬†ï¼Œé–‹å§‹æ ¡æ­£...");
      const interval = setInterval(async () => {
        const value = await characteristic.readValue();
        const emg = parseInt(new TextDecoder().decode(value).trim());
        if (!isNaN(emg)) {
          sum += emg;
          count++;
          if (count >= 100) {
            calibrationBaseline = Math.floor(sum / count);
            isCalibrated = true;
            clearInterval(interval);
            alert("æ ¡æ­£å®Œæˆï¼ŒåŸºæº–å€¼ï¼š" + calibrationBaseline);
          }
        }
      }, 100);
    }

    async function readEMG() {
      if (!characteristic || isPaused) return;
      const value = await characteristic.readValue();
      const emg = parseInt(new TextDecoder().decode(value).trim());
      if (isNaN(emg)) return;

      rawData.push(emg); rawData.shift(); emgChart.update();

      let processed = getProcessedEMG(emg);
      let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
      const amplify = parseFloat(document.getElementById('amplifyRate').value);
      const amplifiedAdjusted = Math.floor(adjusted * amplify);

      zoomData.push(amplifiedAdjusted); zoomData.shift(); zoomChart.update();

      if (amplifiedAdjusted > maxAdjusted) maxAdjusted = amplifiedAdjusted;
      const percent = Math.round((amplifiedAdjusted / maxAdjusted) * 100);
      document.getElementById('value').innerText = 'åŸå§‹æ•¸å€¼ï¼š' + emg;
      document.getElementById('adjusted').innerText = 'æ ¡æ­£å¾Œæ•¸å€¼ï¼š' + amplifiedAdjusted;
      document.getElementById('mvc').innerText = 'å³æ™‚å¼·åº¦ï¼š' + percent + ' %';

      const threshold = parseInt(document.getElementById('soundThreshold').value);
      if (audioCtx && oscillator && gainNode) {
        if (soundEnabled && emg > threshold) {
          oscillator.frequency.setValueAtTime(100 + (emg - threshold) * 2, audioCtx.currentTime);
          gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
        } else {
          gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        }
      }
    }
  </script>
<audio id="mp3Player" preload="auto" src="https://u9010269.github.io/emg-wave-app/350.mp3"></audio>
<script>
let mp3Enabled = false;
let mp3Played = false;
let mp3Player = null;

function toggleMp3() {
  mp3Enabled = !mp3Enabled;
  const btn = document.getElementById("toggleMp3Btn");
  if (btn) {
    btn.innerText = "åˆ‡æ›MP3éŸ³æ•ˆï¼ˆç›®å‰ï¼š" + (mp3Enabled ? "é–‹" : "é—œ") + "ï¼‰";
  }
}

window.addEventListener("DOMContentLoaded", () => {
  mp3Player = document.getElementById("mp3Player");
});

function getProcessedEMG(val) {
  emgBuffer.push(val); emgBuffer.shift();
  if (mode === 'raw') return val;
  if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
  if (mode === 'max') return Math.max(...emgBuffer);
  if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
  return val;
}

async function readEMG() {
  if (!characteristic || isPaused) return;
  const value = await characteristic.readValue();
  const emg = parseInt(new TextDecoder().decode(value).trim());
  if (isNaN(emg)) return;

  rawData.push(emg); rawData.shift(); emgChart.update();

  let processed = getProcessedEMG(emg);
  let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
  const amplify = parseFloat(document.getElementById('amplifyRate').value);
  const amplifiedAdjusted = Math.floor(adjusted * amplify);

  zoomData.push(amplifiedAdjusted); zoomData.shift(); zoomChart.update();

  if (amplifiedAdjusted > maxAdjusted) maxAdjusted = amplifiedAdjusted;
  const percent = Math.round((amplifiedAdjusted / maxAdjusted) * 100);
  document.getElementById('value').innerText = 'åŸå§‹æ•¸å€¼ï¼š' + emg;
  document.getElementById('adjusted').innerText = 'æ ¡æ­£å¾Œæ•¸å€¼ï¼š' + amplifiedAdjusted;
  document.getElementById('mvc').innerText = 'å³æ™‚å¼·åº¦ï¼š' + percent + ' %';

  const mp3Threshold = parseInt(document.getElementById("mp3Threshold").value);
  if (mp3Enabled && mp3Player) {
    if (emg > mp3Threshold && !mp3Played) {
      try {
        mp3Player.currentTime = 0;
        mp3Player.play();
      } catch (err) {
        console.error("æ’­æ”¾å¤±æ•—ï¼š", err);
      }
      mp3Played = true;
    } else if (emg <= mp3Threshold) {
      mp3Played = false;
    }
  }
}
</script>
<script>
let characteristic, pauseBtn = null;
let isPaused = false, isCalibrated = false;
let calibrationBaseline = 0, maxAdjusted = 1;
let mode = 'raw';
const AVG_WINDOW = 10;
let emgBuffer = Array(AVG_WINDOW).fill(0);
const rawData = Array(100).fill(0);
const zoomData = Array(100).fill(0);

let mp3Enabled = false;
let mp3Played = false;
let mp3Player = null;

window.addEventListener("DOMContentLoaded", () => {
  mp3Player = document.getElementById("mp3Player");
});

function toggleMp3() {
  mp3Enabled = !mp3Enabled;
  const btn = document.getElementById("toggleMp3Btn");
  if (btn) {
    btn.innerText = "åˆ‡æ›MP3éŸ³æ•ˆï¼ˆç›®å‰ï¼š" + (mp3Enabled ? "é–‹" : "é—œ") + "ï¼‰";
  }
  if (mp3Enabled && mp3Player) {
    // åƒ…è§£é–éŸ³è¨Šï¼Œä¸æ’­æ”¾
    mp3Player.play().then(() => {
      mp3Player.pause();
      mp3Player.currentTime = 0;
    }).catch(e => console.log("éŸ³è¨Šåˆå§‹åŒ–è¢«æ‹’çµ•ï¼ˆç­‰å¾…äº’å‹•ï¼‰"));
  }
}

const emgChart = new Chart(document.getElementById('emgChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: 'åŸå§‹ EMG', data: rawData, borderColor: 'blue', borderWidth: 1 }] },
  options: { animation: false, responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1023 } } }
});

const zoomChart = new Chart(document.getElementById('zoomChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: 'æ ¡æ­£å¾Œ EMG', data: zoomData, borderColor: 'green', borderWidth: 1 }] },
  options: { animation: false, responsive: true, scales: { y: { min: -100, max: 200 }, x: { grid: { display: true } } } }
});

function getProcessedEMG(val) {
  emgBuffer.push(val); emgBuffer.shift();
  if (mode === 'raw') return val;
  if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
  if (mode === 'max') return Math.max(...emgBuffer);
  if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
  return val;
}

function setMode(m) {
  mode = m;
  alert('æ¨¡å¼åˆ‡æ›ç‚ºï¼š' + m);
}

function resetMax() {
  maxAdjusted = 1;
  zoomChart.update();
}

async function connect() {
  const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'MLT' }], optionalServices: ['ffe0'] });
  const server = await device.gatt.connect();
  const service = await server.getPrimaryService('ffe0');
  characteristic = await service.getCharacteristic('ffe1');
  pauseBtn = document.getElementById('pauseBtn');
  readEMGLoop();  // ä½¿ç”¨éé‡ç–Šæ–¹å¼
}

function togglePause() {
  isPaused = !isPaused;
  pauseBtn.innerText = isPaused ? "æ¢å¾©" : "æš«åœ";
}

async function performCalibration() {
  let sum = 0, count = 0;
  alert("è«‹ä¿æŒæ”¾é¬†ï¼Œé–‹å§‹æ ¡æ­£...");
  const interval = setInterval(async () => {
    const value = await characteristic.readValue();
    const emg = parseInt(new TextDecoder().decode(value).trim());
    if (!isNaN(emg)) {
      sum += emg;
      count++;
      if (count >= 100) {
        calibrationBaseline = Math.floor(sum / count);
        isCalibrated = true;
        clearInterval(interval);
        alert("æ ¡æ­£å®Œæˆï¼ŒåŸºæº–å€¼ï¼š" + calibrationBaseline);
      }
    }
  }, 100);
}

async function readEMGLoop() {
  while (true) {
    await readEMG();
    await new Promise(r => setTimeout(r, 30));
  }
}

async function readEMG() {
  if (!characteristic || isPaused) return;
  const value = await characteristic.readValue();
  const emg = parseInt(new TextDecoder().decode(value).trim());
  if (isNaN(emg)) return;

  rawData.push(emg); rawData.shift(); emgChart.update();

  let processed = getProcessedEMG(emg);
  let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
  const amplify = parseFloat(document.getElementById('amplifyRate').value);
  const amplifiedAdjusted = Math.floor(adjusted * amplify);

  zoomData.push(amplifiedAdjusted); zoomData.shift(); zoomChart.update();

  if (amplifiedAdjusted > maxAdjusted) maxAdjusted = amplifiedAdjusted;
  const percent = Math.round((amplifiedAdjusted / maxAdjusted) * 100);
  document.getElementById('value').innerText = 'åŸå§‹æ•¸å€¼ï¼š' + emg;
  document.getElementById('adjusted').innerText = 'æ ¡æ­£å¾Œæ•¸å€¼ï¼š' + amplifiedAdjusted;
  document.getElementById('mvc').innerText = 'å³æ™‚å¼·åº¦ï¼š' + percent + ' %';

  const mp3Threshold = parseInt(document.getElementById("mp3Threshold").value);
  if (mp3Enabled && mp3Player) {
    if (emg > mp3Threshold && !mp3Played) {
      mp3Player.currentTime = 0;
      mp3Player.play();
      mp3Played = true;
    } else if (emg <= mp3Threshold) {
      mp3Played = false;
    }
  }
}
</script>
<script>
let characteristic, pauseBtn = null;
let isPaused = false, isCalibrated = false;
let calibrationBaseline = 0, maxAdjusted = 1;
let mode = 'raw';
const AVG_WINDOW = 10;
let emgBuffer = Array(AVG_WINDOW).fill(0);
const rawData = Array(100).fill(0);
const zoomData = Array(100).fill(0);

let mp3Enabled = false;
let mp3Played = false;
let mp3Player = null;

window.addEventListener("DOMContentLoaded", () => {
  mp3Player = document.getElementById("mp3Player");
});

function toggleMp3() {
  mp3Enabled = !mp3Enabled;
  const btn = document.getElementById("toggleMp3Btn");
  if (btn) {
    btn.innerText = "åˆ‡æ›MP3éŸ³æ•ˆï¼ˆç›®å‰ï¼š" + (mp3Enabled ? "é–‹" : "é—œ") + "ï¼‰";
  }
  if (mp3Enabled && mp3Player) {
    mp3Player.currentTime = 0;
    mp3Player.play().catch(err => console.warn("éŸ³æ•ˆæ’­æ”¾è§£é–å¤±æ•—ï¼š", err));
  }
}

const emgChart = new Chart(document.getElementById('emgChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: 'åŸå§‹ EMG', data: rawData, borderColor: 'blue', borderWidth: 1 }] },
  options: { animation: false, responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1023 } } }
});

const zoomChart = new Chart(document.getElementById('zoomChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: 'æ ¡æ­£å¾Œ EMG', data: zoomData, borderColor: 'green', borderWidth: 1 }] },
  options: { animation: false, responsive: true, scales: { y: { min: -100, max: 200 }, x: { grid: { display: true } } } }
});

function getProcessedEMG(val) {
  emgBuffer.push(val); emgBuffer.shift();
  if (mode === 'raw') return val;
  if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
  if (mode === 'max') return Math.max(...emgBuffer);
  if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
  return val;
}

function setMode(m) {
  mode = m;
  alert('æ¨¡å¼åˆ‡æ›ç‚ºï¼š' + m);
}

function resetMax() {
  maxAdjusted = 1;
  zoomChart.update();
}

async function connect() {
  const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'MLT' }], optionalServices: ['ffe0'] });
  const server = await device.gatt.connect();
  const service = await server.getPrimaryService('ffe0');
  characteristic = await service.getCharacteristic('ffe1');
  pauseBtn = document.getElementById('pauseBtn');
  readEMGLoop();
}

function togglePause() {
  isPaused = !isPaused;
  pauseBtn.innerText = isPaused ? "æ¢å¾©" : "æš«åœ";
}

async function performCalibration() {
  let sum = 0, count = 0;
  alert("è«‹ä¿æŒæ”¾é¬†ï¼Œé–‹å§‹æ ¡æ­£...");
  const interval = setInterval(async () => {
    const value = await characteristic.readValue();
    const emg = parseInt(new TextDecoder().decode(value).trim());
    if (!isNaN(emg)) {
      sum += emg;
      count++;
      if (count >= 100) {
        calibrationBaseline = Math.floor(sum / count);
        isCalibrated = true;
        clearInterval(interval);
        alert("æ ¡æ­£å®Œæˆï¼ŒåŸºæº–å€¼ï¼š" + calibrationBaseline);
      }
    }
  }, 100);
}

async function readEMGLoop() {
  while (true) {
    await readEMG();
    await new Promise(r => setTimeout(r, 30));
  }
}

async function readEMG() {
  if (!characteristic || isPaused) return;
  const value = await characteristic.readValue();
  const emg = parseInt(new TextDecoder().decode(value).trim());
  if (isNaN(emg) || emg <= 100 || emg >= 1024) return;  // éæ¿¾æ‰ä¸åˆç†å€¼

  rawData.push(emg); rawData.shift(); emgChart.update();

  let processed = getProcessedEMG(emg);
  let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
  const amplify = parseFloat(document.getElementById('amplifyRate').value);
  const amplifiedAdjusted = Math.floor(adjusted * amplify);

  zoomData.push(amplifiedAdjusted); zoomData.shift(); zoomChart.update();

  if (amplifiedAdjusted > maxAdjusted) maxAdjusted = amplifiedAdjusted;
  const percent = Math.round((amplifiedAdjusted / maxAdjusted) * 100);
  document.getElementById('value').innerText = 'åŸå§‹æ•¸å€¼ï¼š' + emg;
  document.getElementById('adjusted').innerText = 'æ ¡æ­£å¾Œæ•¸å€¼ï¼š' + amplifiedAdjusted;
  document.getElementById('mvc').innerText = 'å³æ™‚å¼·åº¦ï¼š' + percent + ' %';

  const mp3Threshold = parseInt(document.getElementById("mp3Threshold").value);
  if (mp3Enabled && mp3Player) {
    if (emg > mp3Threshold && !mp3Played) {
      mp3Player.currentTime = 0;
      mp3Player.play();
      mp3Played = true;
    } else if (emg <= mp3Threshold) {
      mp3Played = false;
    }
  }
}
</script>
</body>
</html>

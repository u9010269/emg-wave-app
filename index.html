<!DOCTYPE html>

<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<title>EMG 回復穩定版（含音效與UI）</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { max-width: 100%; height: 250px; }
    .btn-group { margin-top: 10px; margin-bottom: 10px; }
    button {
      font-size: 1.1em; padding: 8px 16px; margin-right: 10px; margin-bottom: 6px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    select, input[type="number"] {
      font-size: 1em; margin-left: 10px;
    }
  </style>
</head>
<body>
<h2>EMG 原始波形圖（地震圖）</h2>
<div class="btn-group">
<button onclick="connect()" style="background-color:#28a745; color:white;">連接藍牙</button>



<button id="pauseBtn" onclick="togglePause()" style="background-color:#007BFF; color:white;">暫停</button>
</div>
<p id="value">原始數值：--</p>
<canvas id="emgChart"></canvas>
<h2 id="zoomTitle">EMG 校正波形圖（處理模式）
    <button onclick="performCalibration()" style="background-color:#ffc107; color:black; font-size: 0.9em; margin-left: 10px;">📍 校正</button>
</h2>
<canvas id="zoomChart"></canvas>
<p id="adjusted">校正後數值：--</p>
<p id="mvc">即時強度：-- %</p>
<div class="btn-group">
<label>校正數值倍率：
      <select id="amplifyRate">
<option value="1">100%</option>
<option value="1.2">120%</option>
<option value="1.4">140%</option>
<option value="1.6">160%</option>
<option value="1.8">180%</option>
<option value="2">200%</option>
</select>
</label>
</div>
<div class="btn-group">
<button onclick="setMode('raw')" style="background-color:#17a2b8; color:white;">原始</button>
<button onclick="setMode('mean')" style="background-color:#17a2b8; color:white;">平均</button>
<button onclick="setMode('max')" style="background-color:#17a2b8; color:white;">最大值</button>
<button onclick="setMode('rms')" style="background-color:#17a2b8; color:white;">RMS</button>
<button onclick="resetMax()" style="background-color:#6c757d; color:white;">重設最大值</button>
</div>
<script>
    let characteristic, pauseBtn = null;
    
    let calibrationBaseline = 0, maxAdjusted = 1;
    
    let mode = 'raw';
    const AVG_WINDOW = 10;
    let emgBuffer = Array(AVG_WINDOW).fill(0);
    const rawData = Array(100).fill(0);
    const zoomData = Array(100).fill(0);

    const emgChart = new Chart(document.getElementById('emgChart'), {
      type: 'line',
      data: { labels: Array(100).fill(''), datasets: [{ label: '原始 EMG', data: rawData, borderColor: 'blue', borderWidth: 1 }] },
      options: { animation: false, responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1023 } } }
    });

    const zoomChart = new Chart(document.getElementById('zoomChart'), {
      type: 'line',
      data: { labels: Array(100).fill(''), datasets: [{ label: '校正後 EMG', data: zoomData, borderColor: 'green', borderWidth: 1 }] },
      options: { animation: false, responsive: true, scales: { y: { min: -100, max: 200 }, x: { grid: { display: true } } } }
    });

    function getProcessedEMG(val) {
      emgBuffer.push(val); emgBuffer.shift();
      if (mode === 'raw') return val;
      if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
      if (mode === 'max') return Math.max(...emgBuffer);
      if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
      return val;
    }

    function setMode(m) {
      mode = m;
      alert('模式切換為：' + m);
    }

    function resetMax() {
      maxAdjusted = 1;
      zoomChart.update();
    }

    async function connect() {
      const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'MLT' }], optionalServices: ['ffe0'] });
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('ffe0');
      characteristic = await service.getCharacteristic('ffe1');
      pauseBtn = document.getElementById('pauseBtn');
      setInterval(readEMG, 30);
    }

    function togglePause() {
      isPaused = !isPaused;
      pauseBtn.innerText = isPaused ? "恢復" : "暫停";
    }

    function startSoundEngine() {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);
        oscillator = audioCtx.createOscillator();
        oscillator.connect(gainNode);
        oscillator.start();
        gainNode.gain.value = 0;
      }
    }

    

    async function performCalibration() {
      let sum = 0, count = 0;
      alert("請保持放鬆，開始校正...");
      const interval = setInterval(async () => {
        const value = await characteristic.readValue();
        const emg = parseInt(new TextDecoder().decode(value).trim());
        if (!isNaN(emg)) {
          sum += emg;
          count++;
          if (count >= 100) {
            calibrationBaseline = Math.floor(sum / count);
            isCalibrated = true;
            clearInterval(interval);
            alert("校正完成，基準值：" + calibrationBaseline);
          }
        }
      }, 100);
    }

    async function readEMG() {
      if (!characteristic || isPaused) return;
      const value = await characteristic.readValue();
      const emg = parseInt(new TextDecoder().decode(value).trim());
      if (isNaN(emg)) return;

      rawData.push(emg); rawData.shift(); emgChart.update();

      let processed = getProcessedEMG(emg);
      let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
      const amplify = parseFloat(document.getElementById('amplifyRate').value);
      const amplifiedAdjusted = Math.floor(adjusted * amplify);

      zoomData.push(amplifiedAdjusted); zoomData.shift(); zoomChart.update();

      if (amplifiedAdjusted > maxAdjusted) maxAdjusted = amplifiedAdjusted;
      const percent = Math.round((amplifiedAdjusted / maxAdjusted) * 100);
      document.getElementById('value').innerText = '原始數值：' + emg;
      document.getElementById('adjusted').innerText = '校正後數值：' + amplifiedAdjusted;
      document.getElementById('mvc').innerText = '即時強度：' + percent + ' %';

      const threshold = parseInt(document.getElementById('soundThreshold').value);
       else {
          gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        }
      }
    }
  </script>
</body>
</html>

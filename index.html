
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8"/>
  <title>EMG 音效整合穩定版</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { max-width: 100%; height: 250px; }
    .btn-group { margin: 10px 0; }
    button {
      font-size: 1.1em; padding: 8px 16px; margin-right: 10px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    select, input[type="number"] {
      font-size: 1em; margin-left: 10px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<h2>EMG 原始波形圖</h2>
<div class="btn-group">
  <button id="toggleMp3Btn" onclick="toggleMp3()" style="background-color:#ff6600; color:white;">切換MP3音效（目前：關）</button>
  <label>MP3門檻值：<input id="mp3Threshold" type="number" value="350" style="width: 80px;"/></label>
</div>
<div class="btn-group">
  <button onclick="connect()" style="background-color:#28a745; color:white;">連接藍牙</button>
  <button id="pauseBtn" onclick="togglePause()" style="background-color:#007BFF; color:white;">暫停</button>
</div>
<p id="value">原始數值：--</p>
<canvas id="emgChart"></canvas>
<h2>EMG 校正波形圖
  <button onclick="performCalibration()" style="background-color:#ffc107; color:black; font-size: 0.9em;">📍 校正</button>
</h2>
<canvas id="zoomChart"></canvas>
<p id="adjusted">校正後數值：--</p>
<p id="mvc">即時強度：-- %</p>
<div class="btn-group">
  <label>校正數值倍率：
    <select id="amplifyRate">
      <option value="1">100%</option>
      <option value="1.2">120%</option>
      <option value="1.4">140%</option>
      <option value="1.6">160%</option>
      <option value="1.8">180%</option>
      <option value="2">200%</option>
    </select>
  </label>
</div>
<div class="btn-group">
  <button onclick="setMode('raw')" style="background-color:#17a2b8; color:white;">原始</button>
  <button onclick="setMode('mean')" style="background-color:#17a2b8; color:white;">平均</button>
  <button onclick="setMode('max')" style="background-color:#17a2b8; color:white;">最大值</button>
  <button onclick="setMode('rms')" style="background-color:#17a2b8; color:white;">RMS</button>
  <button onclick="resetMax()" style="background-color:#6c757d; color:white;">重設最大值</button>
</div>

<script>
let characteristic = null;
let isPaused = false;
let isCalibrated = false;
let calibrationBaseline = 0;
let maxAdjusted = 1;
let mode = 'raw';
const AVG_WINDOW = 10;
let emgBuffer = Array(AVG_WINDOW).fill(0);
const rawData = Array(100).fill(0);
const zoomData = Array(100).fill(0);
let lastEMG = 0;

// 音效設定
let mp3Enabled = false;
let audioContext = null;
let mp3Buffer = null;

// 圖表初始化
const emgChart = new Chart(document.getElementById('emgChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: '原始 EMG', data: rawData, borderColor: 'blue' }] },
  options: { animation: false, responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1023 } } }
});
const zoomChart = new Chart(document.getElementById('zoomChart'), {
  type: 'line',
  data: { labels: Array(100).fill(''), datasets: [{ label: '校正後 EMG', data: zoomData, borderColor: 'green' }] },
  options: { animation: false, responsive: true, scales: { y: { min: -100, max: 200 } } }
});

// 處理模式
function getProcessedEMG(val) {
  emgBuffer.push(val); emgBuffer.shift();
  if (mode === 'raw') return val;
  if (mode === 'mean') return Math.floor(emgBuffer.reduce((a, b) => a + b, 0) / AVG_WINDOW);
  if (mode === 'max') return Math.max(...emgBuffer);
  if (mode === 'rms') return Math.floor(Math.sqrt(emgBuffer.reduce((a, b) => a + b * b, 0) / AVG_WINDOW));
  return val;
}

function setMode(m) {
  mode = m;
  alert('模式切換為：' + m);
}
function resetMax() {
  maxAdjusted = 1;
}

// 音效切換與初始化
function toggleMp3() {
  mp3Enabled = !mp3Enabled;
  const btn = document.getElementById("toggleMp3Btn");
  if (btn) btn.innerText = "切換MP3音效（目前：" + (mp3Enabled ? "開" : "關") + "）";

  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }

  fetch("https://u9010269.github.io/emg-wave-app/350.mp3")
    .then(resp => resp.arrayBuffer())
    .then(data => audioContext.decodeAudioData(data))
    .then(buffer => {
      mp3Buffer = buffer;
      const source = audioContext.createBufferSource();
      source.buffer = mp3Buffer;
      source.connect(audioContext.destination);
      source.start();
    })
    .catch(err => alert("音效初始化失敗，請再次點擊"));
}

// 讀取 EMG 並更新圖表與音效
async function readEMG() {
  if (!characteristic || isPaused) return;
  const value = await characteristic.readValue();
  const emg = parseInt(new TextDecoder().decode(value).trim());
  if (isNaN(emg)) return;

  rawData.push(emg); rawData.shift(); emgChart.update();
  let processed = getProcessedEMG(emg);
  let adjusted = isCalibrated ? Math.max(0, processed - calibrationBaseline) : 0;
  const amplify = parseFloat(document.getElementById('amplifyRate').value);
  const amplified = Math.floor(adjusted * amplify);
  zoomData.push(amplified); zoomData.shift(); zoomChart.update();
  if (amplified > maxAdjusted) maxAdjusted = amplified;
  const percent = Math.round((amplified / maxAdjusted) * 100);

  document.getElementById('value').innerText = '原始數值：' + emg;
  document.getElementById('adjusted').innerText = '校正後數值：' + amplified;
  document.getElementById('mvc').innerText = '即時強度：' + percent + ' %';

  const threshold = parseInt(document.getElementById('mp3Threshold').value);
  if (mp3Enabled && mp3Buffer && lastEMG <= threshold && emg > threshold) {
    const source = audioContext.createBufferSource();
    source.buffer = mp3Buffer;
    source.connect(audioContext.destination);
    source.start();
  }
  lastEMG = emg;
}

// 連接藍牙與啟動讀取
async function connect() {
  const device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: 'MLT' }], optionalServices: ['ffe0'] });
  const server = await device.gatt.connect();
  const service = await server.getPrimaryService('ffe0');
  characteristic = await service.getCharacteristic('ffe1');
  setInterval(readEMG, 30);
}

// 暫停播放
function togglePause() {
  isPaused = !isPaused;
  document.getElementById("pauseBtn").innerText = isPaused ? "恢復" : "暫停";
}

// 校正基準
async function performCalibration() {
  let sum = 0, count = 0;
  alert("請保持放鬆，開始校正...");
  const interval = setInterval(async () => {
    const value = await characteristic.readValue();
    const emg = parseInt(new TextDecoder().decode(value).trim());
    if (!isNaN(emg)) {
      sum += emg; count++;
      if (count >= 100) {
        calibrationBaseline = Math.floor(sum / count);
        isCalibrated = true;
        clearInterval(interval);
        alert("校正完成，基準值：" + calibrationBaseline);
      }
    }
  }, 100);
}
</script>
</body>
</html>
